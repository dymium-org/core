---
title: "Introduction to dymiumCore"
author: "Amarin Siripanich"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true

vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dymiumCore)
```

This vignette introduces the basic building blocks for microsimulation in `dymiumCore`, how they can be put together to create a microsimulation model, and how to take advantage of existing modules from the [dymiumModules](https://github.com/dymium-org/dymiumModules) repository. 

# Overview of the building blocks 

Microsimulation models, regardless of their study contexts, generally share the same basic components which are entities and rules. The rest of the article focuses on the main building blocks of microsimulation in term of implementation. 

## Entities

Entities can be persons, firms, buildings, zones, transport network etc. They
can be conviniently defined as a class, based on the concept of 'objects' in 
object-oriented programming. Each entity is known by its fields and methods, 
what it represents and what it can do. A person may contains fields such as age, 
gender, marital status. A person give birth, leave parental home, etc.  While 
a household may have household size, household id, number of vehicles owned as
its fields. A household can relocate, have new members and etc.

## Transition

In a microsimulation model, entities are given rules for them to follow under 
different conditions. A rule can simply be an ifelse statement such as:

```
if age is greater than 16:
    can_marry 
else:
    cant_marry
```

This rule is deterministic since it makes sure that all individual agents above the age of 16 can get married.

To use probabilistic rules you may want to use a rate-based model or a classification model 
(binary logit model, multinomial logit model, hazard-based model, random forest, 
and artificial neural network) that takes attributes of the entities as the
input variables.

`dymiumCore` provides `TransitionClassification` and `TransitionRegression`, both are [R6::R6Class], which take in a rule and entities then simulate the outcomes of the entities given the provided rule.  For probabilistic rules, Monte Carlo simulation will be performed based on the probabilistic values from the rules.

### Supported models

Currently, `dymiumCore` only supports the model objects fitted using `caret` and `stats` in the `Transition` classes.

| Package |        Class |                                     Model types |         status |
| ------: | -----------: | ----------------------------------------------: | -------------: |
|   caret |      `train` |            classification and regression models |      supported |
|   stats | `lm` & `glm` |                   generalised regression models |      supported |
|  mlogit |     `mlogit` |                        multinomial logit models | in-development |
|    mlr3 |    `Learner` | classification, survival, and regression models |        planned |


### Using transition probabilities

In microsimulation, modellers often use transition probabilities that they obtained 
from official sources. Hence, __dymiumCore__ provides an easy step to use those
transition probabilities in `Transition`. __A static rate model__, __a dynamic rate model__, 
and __a enumerated choice model__ can be provided in a data.table format. When a
data.table is provided as the model argument to `Transition`, `Transition`  will 
figure out which of the three models the provided data.table matches based on the following criteria. 

It is __a static rate model__, if the data.table contains a column called `prob` which is
of type numeric with the value between 0 to 1.

```{r}
library(data.table) # use install.packages("data.table") to install

(rate_based_model <-
  data.table(
  sex = c("male", "female"),
  prob = c(0.3, 0.2)
))
```

It is __a dynamic rate model__, if the provided data.table contains columns that indicate
time periods with a prefix `t_` follow by a numeric value i.e.  `t_0`, `t_2011`, `t_2050`.
Those time period columns must be of type numeric and the values under those columns 
must be within 0 to 1. 

```{r}
(dynamic_rate_based_model <-
  data.table(
  sex = c("male", "female"),
  prob = c(0.3, 0.2),
  t_2010 = c(0.5, 0.2),
  t_2011 = c(0.3, 0.1),
  t_2012 = c(0.4, 0.3)
))
```

It is __a choice model__, of the provided data.table contains columns that called
`probs` and `choices` of the type list that contains numeric vectors and character
vectors, respectively.  

```{r}
(choice_model <-
  data.table(
    sex = c('male', 'female'),
    probs = list(c(0.3,0.7), c(0.4,0.6)),
    choices = list(c('can drive', 'cannot drive'), c('can drive', 'cannot drive'))
))
```

__Note that__, if more the provided data.table matches more than one of the three formats
then `Transition` will raise an error. 

__Suggestion:__  you can import transition probability tables that are in a `csv` format
or a `.xlsx` format to R using the `fread` function from the `data.table` package or `read.csv()`
from the `utils` package that comes preinstalled with R or `read_xlsx()` from the
`readxl` package for xlsx files.

- A named `list` can be used to represent choices, where the names of the list are 
choices and their values are their associated probabilities. 

```{r}
(binary_list_model <- list(yes = 0.05, no = 0.95))
(marriage_model <- list(married = 0.05, not_married = 0.95))
(employment_model <- list(employed = 0.4, unemployed = 0.2, not_in_labour_force = 0.3))
```

In a binary choice model, it is recommended that the outcome variable should be 
coded as "yes" and "no" as many of the modules available at [dymium-org/dymiumModules](https://github.com/dymium-org/dymiumModules)
use with this convention.

## Market

In microsimulation, a market is where entities are directly interact with one another.
A market can be an abstraction of a real-estate bidding market, a mate matching market,
a labour market, etc. The entire market are separated into two sides (i.e. proposers 
and proprosees, buyers and sellers, labours and firms). Interactions maybe one-sided 
or two-sided depends on the matching mechanism that is used. When it is
one-sided only agents from one side of the market make the decision about what they 
get based on their preference. When it is the matching problem is two-sided one 
then both sides of the market evaluate evaluate options available to them and interact 
in a way that mimic bidding.

Note that, the number of alternatives available to each agent is customisable to realistically 
represent a matching situation that is being simulated. For example, in a housing
search situation, it might be inappropiate to assume that all relocating households 
have perfect knowledge about all the available dwelling units that are on the market
at any moment in time. Hence, the modeller might want to limit the number of alternatives
available in the choiceset of each household or the number of zones that the households
look for their options. 

Currently, there are two implementations of market matching algorithms which are

- Stochastic matching (`MatchingMarketStochastic`) and
- Optimal matching (`MatchingMarketOptimal`)

In `MatchingMarketStochastic`, only one-sided matching problems can be solved. All
agents that are seeking a match are randomly ordered into a virtual queue.
The first agent in the queue gets to select an alternative among all the alternatives
that available to it. While in `MatchingMarketOptimal`, both one-sided and two-sided 
problems can be solved. All agents are aware of all the available alternatives 
(e.g. houses, partners, etc.) in the market. This generally a very strong assumption.
Hence, to mitigate such strong assumption the whole market can be further segmented 
into sub markets where agents that are more alike or geographically near one others
are stratified into the same sub market and only aware of each others and not those
that are their unlikely matches.

## Logging

There are a few ways that you can log in dymium. To choose which of the logging methods is suitable in your please consider the following. Please note that, this subsection is only to give a brief overview of the methods so please see its documentation for more details.

### Logging with `lgr`

The `lgr` package is used by dymiumCore internally. This sometimes give warnings on the console. You can also see lower-level log messages if you change the log threshold.

```{r, eval = FALSE}
dymiumCore:::lg$set_threshold("info")
dymiumCore:::lg$set_threshold("trace")
```

The default threshold for is set to `warn` which only shows warning messages and above (i.e. debug, fatal). As you can see, the internal logger is not exported hence it is not meant to be used by the end-user.

`lgr` is also used in dymium modules. If you create a new module using `use_module()` a lgr logger will be available for you to use within your event functions, see `logger.R` in your module folder.

There are many powerful stuffs you can do with `lgr` and to learn more about it please see its [vignette](https://s-fleck.github.io/lgr/articles/lgr.html). 

### Logging with `Generic$log()`

All classes that inherit `Generic`, namely `Entity` and `Container`, have the `log()` method available to them. The main purpose of this function is to give the user a convinient way to log simulation outputs. `get_log()` can be used on objects that have the `$log()` method to gather all logs.

```{r}
create_toy_world()
total_no_individuals <- world$entities$Individual$n()
world$entities$Individual$log(desc = "total_no_individuals", value = total_no_individuals)
get_log(world)
```

### Logging with `add_history()`

`add_history()` has a more specific used and only applicable to `Entity`, it is meant to be used for logging of past events that occur to each entity. This is particularly useful when past actions of entities can influence their current and future actions. There are helper functions to get and combine histories such as `get_history()` and `combine_histories()`.

```{r}
create_toy_world()
add_history(entity = world$entities$Individual, ids = 1:3, event = "marriage")
get_history(x = world$entities$Individual)
# alternatively you can use insepct to view the attribute data of the individuals
# and their history data at the same time
inspect(entity = world$entities$Individual, ids = 1:3)
```

