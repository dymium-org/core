% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TransitionClassification.R
\name{TransitionClassification}
\alias{TransitionClassification}
\title{Transition for a classification model}
\arguments{
\item{x}{an \link{Entity} object}

\item{model}{any objects of type in \link{SupportedTransitionModels}.}

\item{target}{a named list where the names corresponds to the choices and the values
are the number of agents to choose those choices. This imposes an alignment of
the outcomes to an external constraint.}

\item{targeted_agents}{a integer vector that contains ids of the entities in \code{x}
to undergo this}

\item{model_by_id}{see in the public field section.}
}
\value{
an \link[R6:R6Class]{R6::R6Class} object
}
\description{
\link{TransitionClassification} performs Monte Carlo simulation on a probabilistic
model. In a simpler term, a psuedo random number generator is used to simulate
the outcome based on the probability from the model.

By calling the constructor method of \link{TransitionClassification} this will
initiate the following steps:
\enumerate{
\item \code{initialise(x, model, target, targeted_agents)} ->
\item \code{filter(.data)}: filter agents to apply the transition to.
\item \code{mutate(.data)}: add variables to the data of the filtered agents.
\item \code{simulate()}: simulate the transition outcome using the probabilistic model
\item \code{postprocess(.sim_result)}: post-processing the simulation result.
}

Note that, the order of filter and mutate can be swap by overwriting the \code{mutate_first}
public field to \code{TRUE}. This may be useful in cases where agent selection for
the transition depends on one or more derived variables.

To get the simulation result use \verb{$get_result()}.

Create a \link{TransitionClassification} object.
}
\note{
\code{target} is used ensures that the aggregate outcome of the transition matches
a macro-level outcome as defined in \code{target}. This is known as 'alignment' see,
Li, J., & O'Donoghue, C. (2012). Evaluating binary alignment
methods in microsimulation models. For example, in a transition where the probabilistic
model predicts only two outcomes, a binary model, "yes" and "no". If the target
is a list of yes = 10 and no = 20 (i.e. \verb{r list(yes = 10, no = 20)}), this will
ensure that there will be 10 decision makers whom select 'yes' and 20 decision makers
that select 'no'. However, this doesn't mean that all decision makers have
an equal odd of select 'yes' or 'no', the odd is still to be determined by the given
probalistic model. See \link{alignment} for more detail.
}
\section{Construction}{
\preformatted{TransitionClassification$new(x, model, target = NULL, targeted_agents = NULL)
}
\itemize{
\item \code{x} :: \link[R6:R6Class]{R6::R6Class}\cr
An \link{Entity} object or its inheritances.
\item \code{model} :: \verb{any object} in \link{SupportedTransitionModels}\cr
A model object to be used to simulate transition.
\item \code{target} :: a named \code{list()}\cr
(Default as NULL).
\code{Target} or A named list where its names is a subset of to the choices in \code{model}
to be selected and its values are the number of agents to choose those choices.
See the note section for more details.
\item \code{targeted_agent} :: \code{integer()}\cr
(Default as NULL)
An integer vector that contains agents' ids of the \link{Entity} in \code{x} to undergo
the transition. If this is given then \code{target} will be ignored.
\item \code{model_by_id} :: \code{logical(1)}\cr
This flag is to indicate whether the \code{model} object is meant to be matched
by the id column of the entity object in \code{x} or not. It should be noted that
this flag only matters if the \code{model} object is of type \code{\link[data.table:data.table]{data.table::data.table()}}
where it must contains a numeric column called \code{prob} or list columns of type
numeric and character called \code{probs} and \code{choices}. The model object must have
a column which its name matches with the id column of the entity object in \code{x}.
}
}

\section{Fields}{

\itemize{
\item \code{model_by_id} :: (\code{logical(1)})\cr
See argument in the construction section.
\item \code{mutate_first}:: \code{logical(1)}\cr
Default as FALSE, this flag is used to indicate whether the attribute data from
the Agent in \code{x} should be mutated (\verb{$mutate(.data)}) before filtered (\verb{$filter(.data)}).
}
}

\section{Methods}{

\itemize{
\item \code{filter(.data)}\cr
(\code{\link[data.table:data.table]{data.table::data.table()}}) -> \verb{[data.table::data.table()]}\cr
\strong{(By default, first of the preprocessing steps)}\cr
By default this method returns the input \code{.data}. This method can be overwrite
to give the user the flexibility to 'filter' the data prior to making prediction
by the given model. Filtering for eligible agents for this transition can be done in this step.
\item \code{mutate(.data)}\cr
(\code{\link[data.table:data.table]{data.table::data.table()}}) -> \verb{[data.table::data.table()]}\cr
\strong{(By default, second of the preprocessing steps)}\cr
By default this method returns the input \code{.data}. This method can be overwrite
to give the user the flexibility to 'mutate' the data prior to making prediction
by the given model. Adding derived variables and historical life course of the agents
can be done in this step.
\item \code{update_agents(attr)}\cr
(\code{character(1)})\cr
Update the attribute data of the agents that undergo the transition event.
\item \code{get_result(ids)}\cr
(\code{integer()}) -> \link[data.table:data.table]{data.table::data.table}\cr
Returns the simulation result in a \link[data.table:data.table]{data.table::data.table} format with two
columns \code{id} and \code{response}.
\item \code{get_nrow_result()}\cr
Returns the number of rows in the simulation result.
\item \code{get_decision_maker_ids(response_filter = NULL)}\cr
(\code{character()}) -> (\code{integer()})\cr
Returns ids of the agents that have their response equal to \code{response_filter}.
}
}

\examples{

# create a Individual agent object
Ind <- Individual$new(.data = toy_individuals, id_col = "pid")

# create a probabilistic model
driver_status_rate <- data.table::data.table(
  sex = c('male', 'female'),
  probs = list(c(0.3,0.7), c(0.4,0.6)),
  choices = list(c('can drive', 'cannot drive'), c('can drive', 'cannot drive'))
)

# create a Transition for driver status
TransitionCandrive <- R6::R6Class(
  classname = "TransitionCandrive",
  inherit = TransitionClassification
)

TransCanDrive <- TransitionCandrive$new(x = Ind, model = driver_status_rate)

barplot(
  table(TransCanDrive$get_result()[['response']]),
  main = "Transition result: driver status",
  col = c('steelblue', 'salmon')
)
}
\seealso{
\link{TransitionRegression} and \link{Trans}.
}
