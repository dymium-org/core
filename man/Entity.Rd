% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Entity.R
\name{Entity}
\alias{Entity}
\alias{Entities}
\title{Entity class}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
The base class (first building block) for \link{Agent}, \link{Asset} and \link{Environment}.
}
\section{Fields}{

\describe{
\item{\code{database}}{a list of all \link{DataBackends} of the Entity}
}}

\section{Construction}{
\preformatted{x <- Entity$new(databackend, .data, id_col)
}

Stores \code{.data} as a DataBackend object inside the object's list of data (\code{private$.data})
and registers the \code{id_col} (\code{private$.id_col}).
\itemize{
\item \code{databackend} :: an \link[R6:R6Class]{R6::R6Class} generator]\cr
An \link[R6:R6Class]{R6::R6Class} generator that inherits from \code{DataBackend}.
\item \code{.data} :: \code{data.frame()}\cr
A object that inherits from \code{data.frame}.
\item \code{id_col} :: \code{character(1)}\cr
The id column of \code{.data}.
}
}

\section{Fields}{

\itemize{
\item \code{cont}: a reference semantic to its \link{Container} object. Default as NULL.
}
}

\section{Methods}{

\itemize{
\item \code{add_data(databackend = DataBackendDataTable, .data, name)}\cr
(\code{DataBackend}, \code{data.frame}, \code{character(1)}) -> \code{NULL}\cr
Append new data to the object's data list (\code{private$.data}). the new data
must be linkable with the attribute data of the object by the id_col.
\item \code{check_ids(ids)}\cr
(\code{integer()})\cr
Return true if all ids exist if not raises an informative error.
\item \code{data(name)}\cr
(\code{character(1)}) -> (\verb{[dymiumCore::DataBackend]}|\code{NULL})\cr
Returns a \link{DataBackend} with the name that matches \code{name}.
If \code{name} is not given, the function will try to return the \link{DataBackend} with name \code{attrs}.
If \code{attrs} is not present or no \code{DataBackEnd} objects have been loaded it will
return \code{NULL}.
\item \code{get_id_col}\cr
() -> \code{character(1)}\cr
Returns the column id field of data.
\item \code{get_data(ids, copy = TRUE)}\cr
(\code{integer()}, \code{logical(1)}) -> (\verb{[data.table::data.table()]}|\code{NULL})\cr
Return agent data. When \code{ids} is specified, the data returned has the same
row order as the order of \code{ids}. If \code{copy} is TRUE then data.table's
reference semantics is returned. If \code{attrs} is not present or no \code{DataBackEnd}
objects have been loaded it will return \code{NULL}.
\item \code{get_data_names()}\cr
() -> \code{character()}\cr
Returns the names of all data objects (in \code{private$.data}) that belongs to this object.
\item \code{get_removed_data(name)}\cr
(\code{character(1)}) -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Return removed agent data. If \code{name} is missing, the first data, which should
contains the main attributes of the agent object, will be returned.
\item \code{get_ids(idx)}\cr
(\code{integer()}) -> \code{integer()}\cr
Return the ids of the indexes in the argrument \code{idx}, respectively.
\item \code{get_idx(ids)}\cr
(\code{integer()}) -> \code{integer()}\cr
Return the indexes of the ids in the argrument \code{ids}, respectively.
\item \code{get_attr(x, ids)}\cr
(\code{character(1)}, \code{integer()}) -> \code{vector(type::col)}\cr
Extract the attribute from self$data as vector. If \code{ids} is given then only
the corresponding values to \code{ids} are returned, in the same order as the \code{ids}.
\item \code{has_attr(x)}\cr
(\code{character()}) -> \code{logical()}\cr
Check which of the attribute names given in \code{x} exist in the attribute data
of the object.
\item \code{ids_exist(ids, by_element = FALSE, include_removed_data = FALSE)}\cr
(\code{integer()}, \code{logical(1)}, \code{logical(1)}) -> \code{logical()}\cr
Returns a logical vector of the same length as the argument \code{ids}. This function
checks whether the ids in the argument \code{ids} exist or not. If \code{by_element} is
TRUE then it will return a logical vector with the same length as \code{ids} in
their respective order. And if \code{inclide_removed_data} is TRUE it will check
the removed data to see if the ids ever existed.
\item \code{idx_exist(idx, by_element = FALSE)}\cr
(\code{integer()}) -> \code{logical()}\cr
Returns a logical vector of the same length as the argument \code{idx}. This function
checks whether the indexes in the argument \code{idx} exist or not. If \code{by_element} is
TRUE then it will return a logical vector with the same length as \code{ids} in
their respective order.
\item \code{n()}\cr
() -> \code{integer(1)}\cr
Returns the number of entities represented by this object.
\item \code{print_data(n = 0)}\cr
(\code{logical(1)}) -> \code{self}\cr
Print to console the number of datasets and their dimensions. \code{n} is the number of rows
that will be output to console by \code{head()}, if 0 nothing will be printed.
}
}

